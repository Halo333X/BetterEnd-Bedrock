{
	"format_version": "1.21.0",
	"minecraft:scatter_feature": {
		"description": {
			"identifier": "betterend:painted_mountains/layer_column"
		},
		"places_feature": "betterend:painted_mountains/blocks",
		"iterations": "v.block = v.layer.block; v.span.iteration = v.column.block_iteration - 1; v.layer.content.requires_calculation = 0; v.layer.padding.requires_calculation = 0; v.stratum.placement.subject == 'pattern' ? { v.layer.content.requires_calculation = 1; v.layer.padding.requires_calculation = 1; }; v.stratum.placement.subject == 'block' && v.column.block_iteration < v.stratum.placement.termination.value?{v.layer.content.requires_calculation = 1;};v.layer.content.requires_calculation?{v.layer.content.size.method == 'constant'?{v.layer.content.size.value = v.layer.content.size.value;};v.layer.content.size.method == 'variable'?{v.layer.content.size.variation.method == 'random'?{v.layer.content.size.value = math.random_integer(v.layer.content.size.minimum, v.layer.content.size.maximum);};v.layer.content.size.variation.method == 'sinusoidal'?{v.layer.content.size.value = math.clamp(math.floor((v.layer.content.size.minimum + v.layer.content.size.maximum) / 2 + 0.5 +(math.sin((v.worldx - v.layer.content.size.variation.offset.x - v.layer.content.looping_offset * v.pattern.iteration) / v.layer.content.size.variation.spread) * math.sin((v.worldz - v.layer.content.size.variation.offset.z - v.layer.content.looping_offset * v.pattern.iteration) / v.layer.content.size.variation.spread)) * ((v.layer.content.size.maximum - v.layer.content.size.minimum) / 2 + 0.5)),v.layer.content.size.minimum, v.layer.content.size.maximum); };v.layer.content.size.variation.method == 'noise'?{v.layer.content.size.value = math.clamp(math.floor((v.layer.content.size.minimum + v.layer.content.size.maximum) / 2 + 0.5 +query.noise((v.worldx - v.layer.content.size.variation.offset.x - v.layer.content.looping_offset * v.pattern.iteration) / v.layer.content.size.variation.spread,(v.worldz - v.layer.content.size.variation.offset.z - v.layer.content.looping_offset * v.pattern.iteration) / v.layer.content.size.variation.spread) * ((v.layer.content.size.maximum - v.layer.content.size.minimum) / 2 + 0.5)),v.layer.content.size.minimum,v.layer.content.size.maximum);};};};v.stratum.placement.subject == 'block' && v.column.block_iteration < v.stratum.placement.termination.value?{v.pattern.offset_iteration < v.stratum.placement.offset.value?{v.pattern.offset_iteration = v.pattern.offset_iteration + v.layer.content.size.value;v.pattern.offset_iteration >= v.stratum.placement.offset.value?{v.layer.content.size.value = v.pattern.offset_iteration - v.stratum.placement.offset.value;}:{v.span.length = 0;v.layer.padding.requires_calculation = 1;};};v.pattern.offset_iteration >= v.stratum.placement.offset.value?{v.span.length = math.min(v.layer.content.size.value, v.stratum.placement.termination.value - v.column.block_iteration);v.column.block_iteration = v.column.block_iteration + v.span.length;v.column.block_iteration < v.stratum.placement.termination.value?{v.layer.padding.requires_calculation = 1;};};};v.layer.padding.requires_calculation?{v.layer.padding.size.method == 'constant'?{v.layer.padding.size.value = v.layer.padding.size.value;};v.layer.padding.size.method == 'variable'?{v.layer.padding.size.variation.method == 'random'?{v.layer.padding.size.value = math.random_integer(v.layer.padding.size.minimum, v.layer.padding.size.maximum); };v.layer.padding.size.variation.method == 'sinusoidal'?{v.layer.padding.size.value = math.clamp(math.floor((v.layer.padding.size.minimum + v.layer.padding.size.maximum) / 2 + 0.5 + (math.sin((v.worldx - v.layer.padding.size.variation.offset.x - v.layer.padding.looping_offset * v.pattern.iteration) / v.layer.padding.size.variation.spread) *math.sin((v.worldz - v.layer.padding.size.variation.offset.z - v.layer.padding.looping_offset * v.pattern.iteration) / v.layer.padding.size.variation.spread)) * ((v.layer.padding.size.maximum - v.layer.padding.size.minimum) / 2 + 0.5)), v.layer.padding.size.minimum, v.layer.padding.size.maximum);};v.layer.padding.size.variation.method == 'noise'?{v.layer.padding.size.value = math.clamp(math.floor((v.layer.padding.size.minimum + v.layer.padding.size.maximum) / 2 + 0.5 + query.noise((v.worldx - v.layer.padding.size.variation.offset.x - v.layer.padding.looping_offset * v.pattern.iteration) / v.layer.padding.size.variation.spread,(v.worldz - v.layer.padding.size.variation.offset.z - v.layer.padding.looping_offset * v.pattern.iteration) / v.layer.padding.size.variation.spread) * ((v.layer.padding.size.maximum - v.layer.padding.size.minimum) / 2 + 0.5)),v.layer.padding.size.minimum,v.layer.padding.size.maximum);};};};v.stratum.placement.subject == 'pattern'?{v.span.length = v.layer.content.size.value;v.span.next_offset = v.layer.padding.size.value;v.column.block_iteration = v.column.block_iteration + v.span.length + v.span.next_offset;};v.stratum.placement.subject == 'block' && v.column.block_iteration < v.stratum.placement.termination.value?{v.pattern.offset_iteration < v.stratum.placement.offset.value?{v.pattern.offset_iteration = v.pattern.offset_iteration + v.layer.content.size.value;v.pattern.offset_iteration >= v.stratum.placement.offset.value?{v.layer.padding.size.value = v.pattern.offset_iteration - v.stratum.placement.offset.value;};};v.pattern.offset_iteration >= v.stratum.placement.offset.value?{v.span.next_offset = math.min(v.layer.padding.size.value, v.stratum.placement.termination.value - v.column.block_iteration);v.column.block_iteration = v.column.block_iteration + v.span.next_offset;};};return v.span.length;",
		"x": 0,
		"z": 0,
		"y": "v.span.iteration = v.span.iteration + 1; return v.span.iteration;"
	}
}